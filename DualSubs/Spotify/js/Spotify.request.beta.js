/* README: https://github.com/DualSubs */
console.log('üçø DualSubs: üéµ Spotify Œ≤ Request')
const $platform = platform();
function platform() {
    if ("undefined" !== typeof $environment && $environment["surge-version"])
        return "Surge"
    if ("undefined" !== typeof $environment && $environment["stash-version"])
        return "Stash"
    if ("undefined" !== typeof module && !!module.exports) return "Node.js"
    if ("undefined" !== typeof $task) return "Quantumult X"
    if ("undefined" !== typeof $loon) return "Loon"
    if ("undefined" !== typeof $rocket) return "Shadowrocket"
    if ("undefined" !== typeof Egern) return "Egern"
}

/* https://www.lodashjs.com */
class Lodash {
	static name = "Lodash";
	static version = "1.2.2";
	static about() { return console.log(`\nüüß ${this.name} v${this.version}\n`) };

	static get(object = {}, path = "", defaultValue = undefined) {
		// translate array case to dot case, then split with .
		// a[0].b -> a.0.b -> ['a', '0', 'b']
		if (!Array.isArray(path)) path = this.toPath(path);

		const result = path.reduce((previousValue, currentValue) => {
			return Object(previousValue)[currentValue]; // null undefined get attribute will throwError, Object() can return a object 
		}, object);
		return (result === undefined) ? defaultValue : result;
	}

	static set(object = {}, path = "", value) {
		if (!Array.isArray(path)) path = this.toPath(path);
		path
			.slice(0, -1)
			.reduce(
				(previousValue, currentValue, currentIndex) =>
					(Object(previousValue[currentValue]) === previousValue[currentValue])
						? previousValue[currentValue]
						: previousValue[currentValue] = (/^\d+$/.test(path[currentIndex + 1]) ? [] : {}),
				object
			)[path[path.length - 1]] = value;
		return object
	}

	static unset(object = {}, path = "") {
		if (!Array.isArray(path)) path = this.toPath(path);
		let result = path.reduce((previousValue, currentValue, currentIndex) => {
			if (currentIndex === path.length - 1) {
				delete previousValue[currentValue];
				return true
			}
			return Object(previousValue)[currentValue]
		}, object);
		return result
	}

	static toPath(value) {
		return value.replace(/\[(\d+)\]/g, '.$1').split('.').filter(Boolean);
	}

	static escape(string) {
		const map = {
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;',
			'"': '&quot;',
			"'": '&#39;',
		};
		return string.replace(/[&<>"']/g, m => map[m])
	};

	static unescape(string) {
		const map = {
			'&amp;': '&',
			'&lt;': '<',
			'&gt;': '>',
			'&quot;': '"',
			'&#39;': "'",
		};
		return string.replace(/&amp;|&lt;|&gt;|&quot;|&#39;/g, m => map[m])
	}

}

/* https://developer.mozilla.org/zh-CN/docs/Web/API/Storage/setItem */
class Storage {
	static name = "Storage";
	static version = "1.1.0";
	static about () { return log("", `üüß ${this.name} v${this.version}`, "") };
	static data = null;
	static dataFile = 'box.dat';
	static #nameRegex = /^@(?<key>[^.]+)(?:\.(?<path>.*))?$/;

    static getItem(keyName = new String, defaultValue = null) {
        let keyValue = defaultValue;
        // Â¶ÇÊûú‰ª• @
		switch (keyName.startsWith('@')) {
			case true:
				const { key, path } = keyName.match(this.#nameRegex)?.groups;
				//log(`1: ${key}, ${path}`);
				keyName = key;
				let value = this.getItem(keyName, {});
				//log(`2: ${JSON.stringify(value)}`)
				if (typeof value !== "object") value = {};
				//log(`3: ${JSON.stringify(value)}`)
				keyValue = Lodash.get(value, path);
				//log(`4: ${JSON.stringify(keyValue)}`)
				try {
					keyValue = JSON.parse(keyValue);
				} catch (e) {
					// do nothing
				}				//log(`5: ${JSON.stringify(keyValue)}`)
				break;
			default:
				switch ($platform) {
					case 'Surge':
					case 'Loon':
					case 'Stash':
					case 'Egern':
					case 'Shadowrocket':
						keyValue = $persistentStore.read(keyName);
						break;
					case 'Quantumult X':
						keyValue = $prefs.valueForKey(keyName);
						break;
					case 'Node.js':
						this.data = this.#loaddata(this.dataFile);
						keyValue = this.data?.[keyName];
						break;
					default:
						keyValue = this.data?.[keyName] || null;
						break;
				}				try {
					keyValue = JSON.parse(keyValue);
				} catch (e) {
					// do nothing
				}				break;
		}		return keyValue ?? defaultValue;
    };

	static setItem(keyName = new String, keyValue = new String) {
		let result = false;
		//log(`0: ${typeof keyValue}`);
		switch (typeof keyValue) {
			case "object":
				keyValue = JSON.stringify(keyValue);
				break;
			default:
				keyValue = String(keyValue);
				break;
		}		switch (keyName.startsWith('@')) {
			case true:
				const { key, path } = keyName.match(this.#nameRegex)?.groups;
				//log(`1: ${key}, ${path}`);
				keyName = key;
				let value = this.getItem(keyName, {});
				//log(`2: ${JSON.stringify(value)}`)
				if (typeof value !== "object") value = {};
				//log(`3: ${JSON.stringify(value)}`)
				Lodash.set(value, path, keyValue);
				//log(`4: ${JSON.stringify(value)}`)
				result = this.setItem(keyName, value);
				//log(`5: ${result}`)
				break;
			default:
				switch ($platform) {
					case 'Surge':
					case 'Loon':
					case 'Stash':
					case 'Egern':
					case 'Shadowrocket':
						result = $persistentStore.write(keyValue, keyName);
						break;
					case 'Quantumult X':
						result =$prefs.setValueForKey(keyValue, keyName);
						break;
					case 'Node.js':
						this.data = this.#loaddata(this.dataFile);
						this.data[keyName] = keyValue;
						this.#writedata(this.dataFile);
						result = true;
						break;
					default:
						result = this.data?.[keyName] || null;
						break;
				}				break;
		}		return result;
	};

    static removeItem(keyName){
		let result = false;
		switch (keyName.startsWith('@')) {
			case true:
				const { key, path } = keyName.match(this.#nameRegex)?.groups;
				keyName = key;
				let value = this.getItem(keyName);
				if (typeof value !== "object") value = {};
				keyValue = Lodash.unset(value, path);
				result = this.setItem(keyName, value);
				break;
			default:
				switch ($platform) {
					case 'Surge':
					case 'Loon':
					case 'Stash':
					case 'Egern':
					case 'Shadowrocket':
						result = false;
						break;
					case 'Quantumult X':
						result = $prefs.removeValueForKey(keyName);
						break;
					case 'Node.js':
						result = false;
						break;
					default:
						result = false;
						break;
				}				break;
		}		return result;
    }

    static clear() {
		let result = false;
		switch ($platform) {
			case 'Surge':
			case 'Loon':
			case 'Stash':
			case 'Egern':
			case 'Shadowrocket':
				result = false;
				break;
			case 'Quantumult X':
				result = $prefs.removeAllValues();
				break;
			case 'Node.js':
				result = false;
				break;
			default:
				result = false;
				break;
		}		return result;
    }

	static #loaddata(dataFile) {
		if (this.isNode()) {
			this.fs = this.fs ? this.fs : require('fs');
			this.path = this.path ? this.path : require('path');
			const curDirDataFilePath = this.path.resolve(dataFile);
			const rootDirDataFilePath = this.path.resolve(
				process.cwd(),
				dataFile
			);
			const isCurDirDataFile = this.fs.existsSync(curDirDataFilePath);
			const isRootDirDataFile =
				!isCurDirDataFile && this.fs.existsSync(rootDirDataFilePath);
			if (isCurDirDataFile || isRootDirDataFile) {
				const datPath = isCurDirDataFile
					? curDirDataFilePath
					: rootDirDataFilePath;
				try {
					return JSON.parse(this.fs.readFileSync(datPath))
				} catch (e) {
					return {}
				}
			} else return {}
		} else return {}
	}

	static #writedata(dataFile = this.dataFile) {
		if (this.isNode()) {
			this.fs = this.fs ? this.fs : require('fs');
			this.path = this.path ? this.path : require('path');
			const curDirDataFilePath = this.path.resolve(dataFile);
			const rootDirDataFilePath = this.path.resolve(
				process.cwd(),
				dataFile
			);
			const isCurDirDataFile = this.fs.existsSync(curDirDataFilePath);
			const isRootDirDataFile =
				!isCurDirDataFile && this.fs.existsSync(rootDirDataFilePath);
			const jsondata = JSON.stringify(this.data);
			if (isCurDirDataFile) {
				this.fs.writeFileSync(curDirDataFilePath, jsondata);
			} else if (isRootDirDataFile) {
				this.fs.writeFileSync(rootDirDataFilePath, jsondata);
			} else {
				this.fs.writeFileSync(curDirDataFilePath, jsondata);
			}
		}
	};

}

function initGotEnv(opts) {
    this.got = this.got ? this.got : require("got");
    this.cktough = this.cktough ? this.cktough : require("tough-cookie");
    this.ckjar = this.ckjar ? this.ckjar : new this.cktough.CookieJar();
    if (opts) {
        opts.headers = opts.headers ? opts.headers : {};
        if (undefined === opts.headers.Cookie && undefined === opts.cookieJar) {
            opts.cookieJar = this.ckjar;
        }
    }}

async function fetch(request = {} || "", option = {}) {
    // ÂàùÂßãÂåñÂèÇÊï∞
    switch (request.constructor) {
        case Object:
            request = { ...option, ...request };
            break;
        case String:
            request = { ...option, "url": request };
            break;
    }    // Ëá™Âä®Âà§Êñ≠ËØ∑Ê±ÇÊñπÊ≥ï
    if (!request.method) {
        request.method = "GET";
        if (request.body ?? request.bodyBytes) request.method = "POST";
    }    // ÁßªÈô§ËØ∑Ê±ÇÂ§¥‰∏≠ÁöÑÈÉ®ÂàÜÂèÇÊï∞, ËÆ©ÂÖ∂Ëá™Âä®ÁîüÊàê
    delete request.headers?.Host;
    delete request.headers?.[":authority"];
    delete request.headers?.["Content-Length"];
    delete request.headers?.["content-length"];
    // ÂÆö‰πâËØ∑Ê±ÇÊñπÊ≥ïÔºàÂ∞èÂÜôÔºâ
    const method = request.method.toLocaleLowerCase();
    // Âà§Êñ≠Âπ≥Âè∞
    switch ($platform) {
        case "Loon":
        case "Surge":
        case "Stash":
        case "Egern":
        case "Shadowrocket":
        default:
            // ËΩ¨Êç¢ËØ∑Ê±ÇÂèÇÊï∞
            if (request.timeout) {
                request.timeout = parseInt(request.timeout, 10);
                switch ($platform) {
                    case "Loon":
                    case "Shadowrocket":
                    case "Stash":
                    case "Egern":
                    default:
                        request.timeout = request.timeout / 1000;
                        break;
                    case "Surge":
                        break;
                }            }            if (request.policy) {
                switch ($platform) {
                    case "Loon":
                        request.node = request.policy;
                        break;
                    case "Stash":
                        Lodash.set(request, "headers.X-Stash-Selected-Proxy", encodeURI(request.policy));
                        break;
                    case "Shadowrocket":
                        Lodash.set(request, "headers.X-Surge-Proxy", request.policy);
                        break;
                }            }            if (typeof request.redirection === "boolean") request["auto-redirect"] = request.redirection;
            // ËΩ¨Êç¢ËØ∑Ê±Ç‰Ωì
            if (request.bodyBytes && !request.body) {
                request.body = request.bodyBytes;
                delete request.bodyBytes;
            }            // ÂèëÈÄÅËØ∑Ê±Ç
            return await new Promise((resolve, reject) => {
                $httpClient[method](request, (error, response, body) => {
                    if (error) reject(error);
                    else {
                        response.ok = /^2\d\d$/.test(response.status);
                        response.statusCode = response.status;
                        if (body) {
                            response.body = body;
                            if (request["binary-mode"] == true) response.bodyBytes = body;
                        }                        resolve(response);
                    }
                });
            });
        case "Quantumult X":
            // ËΩ¨Êç¢ËØ∑Ê±ÇÂèÇÊï∞
            if (request.policy) Lodash.set(request, "opts.policy", request.policy);
            if (typeof request["auto-redirect"] === "boolean") Lodash.set(request, "opts.redirection", request["auto-redirect"]);
            // ËΩ¨Êç¢ËØ∑Ê±Ç‰Ωì
            if (request.body instanceof ArrayBuffer) {
                request.bodyBytes = request.body;
                delete request.body;
            } else if (ArrayBuffer.isView(request.body)) {
                request.bodyBytes = request.body.buffer.slice(request.body.byteOffset, request.body.byteLength + request.body.byteOffset);
                delete object.body;
            } else if (request.body) delete request.bodyBytes;
            // ÂèëÈÄÅËØ∑Ê±Ç
            return await $task.fetch(request).then(
                response => {
                    response.ok = /^2\d\d$/.test(response.statusCode);
                    response.status = response.statusCode;
                    return response;
                },
                reason => Promise.reject(reason.error));
        case "Node.js":
            let iconv = require("iconv-lite");
            initGotEnv(request);
            const { url, ...option } = request;
            return await this.got[method](url, option)
                .on("redirect", (response, nextOpts) => {
                    try {
                        if (response.headers["set-cookie"]) {
                            const ck = response.headers["set-cookie"]
                                .map(this.cktough.Cookie.parse)
                                .toString();
                            if (ck) {
                                this.ckjar.setCookieSync(ck, null);
                            }
                            nextOpts.cookieJar = this.ckjar;
                        }
                    } catch (e) {
                        this.logErr(e);
                    }
                    // this.ckjar.setCookieSync(response.headers["set-cookie"].map(Cookie.parse).toString())
                })
                .then(
                    response => {
                        response.statusCode = response.status;
                        response.body = iconv.decode(response.rawBody, "utf-8");
                        response.bodyBytes = response.rawBody;
                        return response;
                    },
                    error => Promise.reject(error.message));
    }}

function logError(error) {
    switch ($platform) {
        case "Surge":
        case "Loon":
        case "Stash":
        case "Egern":
        case "Shadowrocket":
        case "Quantumult X":
        default:
            log("", `‚ùóÔ∏èÊâßË°åÈîôËØØ!`, error, "");
            break
        case "Node.js":
            log("", `‚ùóÔ∏èÊâßË°åÈîôËØØ!`, error.stack, "");
            break
    }}

function done(object = {}) {
    switch ($platform) {
        case "Surge":
            if (object.policy) Lodash.set(object, "headers.X-Surge-Policy", object.policy);
            log("", `üö© ÊâßË°åÁªìÊùü! üïõ ${(new Date().getTime() / 1000 - $script.startTime)} Áßí`, "");
            $done(object);
            break;
        case "Loon":
            if (object.policy) object.node = object.policy;
            log("", `üö© ÊâßË°åÁªìÊùü! üïõ ${(new Date() - $script.startTime) / 1000} Áßí`, "");
            $done(object);
            break;
        case "Stash":
            if (object.policy) Lodash.set(object, "headers.X-Stash-Selected-Proxy", encodeURI(object.policy));
            log("", `üö© ÊâßË°åÁªìÊùü! üïõ ${(new Date() - $script.startTime) / 1000} Áßí`, "");
            $done(object);
            break;
        case "Egern":
            log("", `üö© ÊâßË°åÁªìÊùü!`, "");
            $done(object);
            break;
        case "Shadowrocket":
        default:
            log("", `üö© ÊâßË°åÁªìÊùü!`, "");
            $done(object);
            break;
        case "Quantumult X":
            if (object.policy) Lodash.set(object, "opts.policy", object.policy);
            // ÁßªÈô§‰∏çÂèØÂÜôÂ≠óÊÆµ
            delete object["auto-redirect"];
            delete object["auto-cookie"];
            delete object["binary-mode"];
            delete object.charset;
            delete object.host;
            delete object.insecure;
            delete object.method; // 1.4.x ‰∏çÂèØÂÜô
            delete object.opt; // $task.fetch() ÂèÇÊï∞, ‰∏çÂèØÂÜô
            delete object.path; // ÂèØÂÜô, ‰ΩÜ‰ºö‰∏é url ÂÜ≤Á™Å
            delete object.policy;
            delete object["policy-descriptor"];
            delete object.scheme;
            delete object.sessionIndex;
            delete object.statusCode;
            delete object.timeout;
            if (object.body instanceof ArrayBuffer) {
                object.bodyBytes = object.body;
                delete object.body;
            } else if (ArrayBuffer.isView(object.body)) {
                object.bodyBytes = object.body.buffer.slice(object.body.byteOffset, object.body.byteLength + object.body.byteOffset);
                delete object.body;
            } else if (object.body) delete object.bodyBytes;
            log("", `üö© ÊâßË°åÁªìÊùü!`, "");
            $done(object);
            break;
        case "Node.js":
            log("", `üö© ÊâßË°åÁªìÊùü!`, "");
            process.exit(1);
            break;
    }
}

const log = (...logs) => console.log(logs.join("\n"));

var Settings$1 = {
	Switch: true,
	Type: "Translate",
	Types: [
		"Official",
		"Translate"
	],
	Languages: [
		"EN",
		"ZH"
	],
	CacheSize: 50
};
var Configs = {
	breakLine: {
		"text/xml": "&#x000A;",
		"application/xml": "&#x000A;",
		"text/vtt": "\n",
		"application/vtt": "\n",
		"text/json": "\n",
		"application/json": "\n"
	}
};
var Default = {
	Settings: Settings$1,
	Configs: Configs
};

var Default$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Configs: Configs,
    Settings: Settings$1,
    default: Default
});

var Settings = {
	Switch: true,
	Types: [
		"Translate",
		"External"
	],
	Languages: [
		"AUTO",
		"ZH"
	]
};
var Spotify = {
	Settings: Settings
};

var Spotify$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Settings: Settings,
    default: Spotify
});

var Database$1 = Database = {
	"Default": Default$1,
	"Spotify": Spotify$1,
};

/**
 * Get Storage Variables
 * @link https://github.com/NanoCat-Me/utils/blob/main/getStorage.mjs
 * @author VirgilClyne
 * @param {String} key - Persistent Store Key
 * @param {Array} names - Platform Names
 * @param {Object} database - Default Database
 * @return {Object} { Settings, Caches, Configs }
 */
function getStorage(key, names, database) {
    //log(`‚òëÔ∏è getStorage, Get Environment Variables`, "");
    /***************** BoxJs *****************/
    // ÂåÖË£Ö‰∏∫Â±ÄÈÉ®ÂèòÈáèÔºåÁî®ÂÆåÈáäÊîæÂÜÖÂ≠ò
    // BoxJsÁöÑÊ∏ÖÁ©∫Êìç‰ΩúËøîÂõûÂÅáÂÄºÁ©∫Â≠óÁ¨¶‰∏≤, ÈÄªËæëÊàñÊìç‰ΩúÁ¨¶‰ºöÂú®Â∑¶‰æßÊìç‰ΩúÊï∞‰∏∫ÂÅáÂÄºÊó∂ËøîÂõûÂè≥‰æßÊìç‰ΩúÊï∞„ÄÇ
    let BoxJs = Storage.getItem(key, database);
    //log(`üöß getStorage, Get Environment Variables`, `BoxJsÁ±ªÂûã: ${typeof BoxJs}`, `BoxJsÂÜÖÂÆπ: ${JSON.stringify(BoxJs)}`, "");
    /***************** Argument *****************/
    let Argument = {};
    switch (typeof $argument) {
        case "string":
            let arg = Object.fromEntries($argument.split("&").map((item) => item.split("=").map(i => i.replace(/\"/g, ''))));
            for (let item in arg) Lodash.set(Argument, item, arg[item]);
            break;
        case "object":
            for (let item in $argument) Lodash.set(Argument, item, $argument[item]);
            break;
    }    //log(`‚úÖ getStorage, Get Environment Variables`, `ArgumentÁ±ªÂûã: ${typeof Argument}`, `ArgumentÂÜÖÂÆπ: ${JSON.stringify(Argument)}`, "");
    /***************** Store *****************/
    const Store = { Settings: database?.Default?.Settings || {}, Configs: database?.Default?.Configs || {}, Caches: {} };
    if (!Array.isArray(names)) names = [names];
    //log(`üöß getStorage, Get Environment Variables`, `namesÁ±ªÂûã: ${typeof names}`, `namesÂÜÖÂÆπ: ${JSON.stringify(names)}`, "");
    for (let name of names) {
        Store.Settings = { ...Store.Settings, ...database?.[name]?.Settings, ...Argument, ...BoxJs?.[name]?.Settings };
        Store.Configs = { ...Store.Configs, ...database?.[name]?.Configs };
        if (BoxJs?.[name]?.Caches && typeof BoxJs?.[name]?.Caches === "string") BoxJs[name].Caches = JSON.parse(BoxJs?.[name]?.Caches);
        Store.Caches = { ...Store.Caches, ...BoxJs?.[name]?.Caches };
    }    //log(`üöß getStorage, Get Environment Variables`, `Store.SettingsÁ±ªÂûã: ${typeof Store.Settings}`, `Store.Settings: ${JSON.stringify(Store.Settings)}`, "");
    traverseObject(Store.Settings, (key, value) => {
        //log(`üöß getStorage, traverseObject`, `${key}: ${typeof value}`, `${key}: ${JSON.stringify(value)}`, "");
        if (value === "true" || value === "false") value = JSON.parse(value); // Â≠óÁ¨¶‰∏≤ËΩ¨Boolean
        else if (typeof value === "string") {
            if (value.includes(",")) value = value.split(",").map(item => string2number(item)); // Â≠óÁ¨¶‰∏≤ËΩ¨Êï∞ÁªÑËΩ¨Êï∞Â≠ó
            else value = string2number(value); // Â≠óÁ¨¶‰∏≤ËΩ¨Êï∞Â≠ó
        }        return value;
    });
    //log(`‚úÖ getStorage, Get Environment Variables`, `Store: ${typeof Store.Caches}`, `StoreÂÜÖÂÆπ: ${JSON.stringify(Store)}`, "");
    return Store;
    /***************** function *****************/
    function traverseObject(o, c) { for (var t in o) { var n = o[t]; o[t] = "object" == typeof n && null !== n ? traverseObject(n, c) : c(t, n); } return o }
    function string2number(string) { if (string && !isNaN(string)) string = parseInt(string, 10); return string }
}

/**
 * Set Environment Variables
 * @author VirgilClyne
 * @param {String} name - Persistent Store Key
 * @param {Array} platforms - Platform Names
 * @param {Object} database - Default DataBase
 * @return {Object} { Settings, Caches, Configs }
 */
function setENV(name, platforms, database) {
	log(`‚òëÔ∏è Set Environment Variables`, "");
	let { Settings, Caches, Configs } = getStorage(name, platforms, database);
	/***************** Settings *****************/
	if (!Array.isArray(Settings?.Types)) Settings.Types = (Settings.Types) ? [Settings.Types] : []; // Âè™Êúâ‰∏Ä‰∏™ÈÄâÈ°πÊó∂ÔºåÊó†ÈÄóÂè∑ÂàÜÈöî
	log(`‚úÖ Set Environment Variables, Settings: ${typeof Settings}, SettingsÂÜÖÂÆπ: ${JSON.stringify(Settings)}`, "");
	/***************** Caches *****************/
	//console.log(`‚úÖ Set Environment Variables, Caches: ${typeof Caches}, CachesÂÜÖÂÆπ: ${JSON.stringify(Caches)}`, "");
	if (typeof Caches?.Playlists !== "object" || Array.isArray(Caches?.Playlists)) Caches.Playlists = {}; // ÂàõÂª∫PlaylistsÁºìÂ≠ò
	Caches.Playlists.Master = new Map(JSON.parse(Caches?.Playlists?.Master || "[]")); // StringsËΩ¨ArrayËΩ¨Map
	Caches.Playlists.Subtitle = new Map(JSON.parse(Caches?.Playlists?.Subtitle || "[]")); // StringsËΩ¨ArrayËΩ¨Map
	if (typeof Caches?.Subtitles !== "object") Caches.Subtitles = new Map(JSON.parse(Caches?.Subtitles || "[]")); // StringsËΩ¨ArrayËΩ¨Map
	if (typeof Caches?.Metadatas !== "object" || Array.isArray(Caches?.Metadatas)) Caches.Metadatas = {}; // ÂàõÂª∫PlaylistsÁºìÂ≠ò
	if (typeof Caches?.Metadatas?.Tracks !== "object") Caches.Metadatas.Tracks = new Map(JSON.parse(Caches?.Metadatas?.Tracks || "[]")); // StringsËΩ¨ArrayËΩ¨Map
	/***************** Configs *****************/
	return { Settings, Caches, Configs };
}

/**
 * Set Cache
 * @author VirgilClyne
 * @param {Map} cache - Playlists Cache / Subtitles Cache
 * @param {Number} cacheSize - Cache Size
 * @return {Boolean} isSaved
 */
function setCache(cache, cacheSize = 100) {
	console.log(`‚òëÔ∏è Set Cache, cacheSize: ${cacheSize}`, "");
	cache = Array.from(cache || []); // MapËΩ¨Array
	cache = cache.slice(-cacheSize); // ÈôêÂà∂ÁºìÂ≠òÂ§ßÂ∞è
	console.log(`‚úÖ Set Cache`, "");
	return cache;
}

log("v1.5.0(1006)");
// ÊûÑÈÄ†ÂõûÂ§çÊï∞ÊçÆ
let $response = undefined;
/***************** Processing *****************/
// Ëß£ÊûÑURL
const url = new URL($request.url);
log(`‚ö† url: ${url.toJSON()}`, "");
// Ëé∑ÂèñËøûÊé•ÂèÇÊï∞
const METHOD = $request.method, HOST = url.hostname, PATH = url.pathname, PATHs = url.pathname.split("/").filter(Boolean);
log(`‚ö† METHOD: ${METHOD}, HOST: ${HOST}, PATH: ${PATH}` , "");
// Ëß£ÊûêÊ†ºÂºè
const FORMAT = ($request.headers?.["Content-Type"] ?? $request.headers?.["content-type"])?.split(";")?.[0];
log(`‚ö† FORMAT: ${FORMAT}`, "");
!(async () => {
	// ËØªÂèñËÆæÁΩÆ
	const { Settings, Caches, Configs } = setENV("DualSubs", "Spotify", Database$1);
	log(`‚ö† Settings.Switch: ${Settings?.Switch}`, "");
	switch (Settings.Switch) {
		case true:
		default:
			// Ëé∑ÂèñÂ≠óÂπïÁ±ªÂûã‰∏éËØ≠Ë®Ä
			const Type = url.searchParams.get("subtype") ?? Settings.Type, Languages = [url.searchParams.get("lang")?.toUpperCase?.() ?? Settings.Languages[0], (url.searchParams.get("tlang") ?? Caches?.tlang)?.toUpperCase?.() ?? Settings.Languages[1]];
			log(`‚ö† Type: ${Type}, Languages: ${Languages}`, "");
			// ÂàõÂª∫Á©∫Êï∞ÊçÆ
			let body = {};
			// ÊñπÊ≥ïÂà§Êñ≠
			switch (METHOD) {
				case "POST":
				case "PUT":
				case "PATCH":
				case "DELETE":
					// Ê†ºÂºèÂà§Êñ≠
					switch (FORMAT) {
						case undefined: // ËßÜ‰∏∫Êó†body
							break;
						case "application/x-www-form-urlencoded":
						case "text/plain":
						default:
							break;
						case "application/x-mpegURL":
						case "application/x-mpegurl":
						case "application/vnd.apple.mpegurl":
						case "audio/mpegurl":
							//body = M3U8.parse($request.body);
							//log(`üöß body: ${JSON.stringify(body)}`, "");
							//$request.body = M3U8.stringify(body);
							break;
						case "text/xml":
						case "text/html":
						case "text/plist":
						case "application/xml":
						case "application/plist":
						case "application/x-plist":
							//body = XML.parse($request.body);
							//log(`üöß body: ${JSON.stringify(body)}`, "");
							//$request.body = XML.stringify(body);
							break;
						case "text/vtt":
						case "application/vtt":
							//body = VTT.parse($request.body);
							//log(`üöß body: ${JSON.stringify(body)}`, "");
							//$request.body = VTT.stringify(body);
							break;
						case "text/json":
						case "application/json":
							//body = JSON.parse($request.body ?? "{}");
							//log(`üöß body: ${JSON.stringify(body)}`, "");
							//$request.body = JSON.stringify(body);
							break;
						case "application/protobuf":
						case "application/x-protobuf":
						case "application/vnd.google.protobuf":
						case "application/grpc":
						case "application/grpc+proto":
						case "application/octet-stream":
							//log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `$request: ${JSON.stringify($request, null, 2)}`, "");
							let rawBody = ($platform === "Quantumult X") ? new Uint8Array($request.bodyBytes ?? []) : $request.body ?? new Uint8Array();
							//log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `isBuffer? ${ArrayBuffer.isView(rawBody)}: ${JSON.stringify(rawBody)}`, "");
							switch (FORMAT) {
								case "application/protobuf":
								case "application/x-protobuf":
								case "application/vnd.google.protobuf":
									switch (PATH) {
										case "/bootstrap/v1/bootstrap":
										case "/user-customization-service/v1/customize":
											delete $request.headers?.["If-None-Match"];
											delete $request.headers?.["if-none-match"];
											break;
									}									break;
							}							// ÂÜôÂÖ•‰∫åËøõÂà∂Êï∞ÊçÆ
							$request.body = rawBody;
							break;
					}					//break; // ‰∏ç‰∏≠Êñ≠ÔºåÁªßÁª≠Â§ÑÁêÜURL
				case "GET":
					if (PATH.startsWith("/color-lyrics/v2/track/")) {
						let trackId = PATHs?.[3];
						log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `trackId: ${trackId}`, "");
						let _request = JSON.parse(JSON.stringify($request));
						_request.url = `https://api.spotify.com/v1/tracks?ids=${trackId}`;
						if (_request?.headers?.Accept) _request.headers.Accept = "application/json";
						if (_request?.headers?.accept) _request.headers.accept = "application/json";
						//log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `_request: ${JSON.stringify(_request)}`, "");
						const detectStutus = fetch($request);
						const detectTrack = fetch(_request);
						await Promise.allSettled([detectStutus, detectTrack]).then(results => {
							/*
							results.forEach((result, i) => {
								log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `result[${i}]: ${JSON.stringify(result)}`, "");
							});
							*/
							switch (results[0].status) {
								case "fulfilled":
									let response = results[0].value;
									switch (response?.statusCode ?? response?.status) {
										case 200:
											if (Settings.Types.includes("Translate")) url.searchParams.set("subtype", "Translate");
											else if (Settings.Types.includes("External")) url.searchParams.set("subtype", "External");
											break;
										case 401:
										default:
											break;
										case 404:
											if (Settings.Types.includes("External")) url.searchParams.set("subtype", "External");
											break;
									}									break;
								case "rejected":
									log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `detectStutus.reason: ${JSON.stringify(results[0].reason)}`, "");
									if (Settings.Types.includes("External")) url.searchParams.set("subtype", "External");
									break;
							}							switch (results[1].status) {
								case "fulfilled":
									let response = results[1].value;
									body = JSON.parse(response.body);
									body?.tracks?.forEach?.(track => {
										//log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `track: ${JSON.stringify(track)}`, "");
										const trackId = track?.id;
										const trackInfo = {
											"id": track?.id,
											"track": track?.name,
											"album": track?.album?.name,
											"artist": track?.artists?.[0]?.name
										};
										// ÂÜôÂÖ•Êï∞ÊçÆ
										Caches.Metadatas.Tracks.set(trackId, trackInfo);
									});
									// Ê†ºÂºèÂåñÁºìÂ≠ò
									log(`üöß Caches.Metadatas.Tracks: ${JSON.stringify([...Caches.Metadatas.Tracks.entries()])}`, "");
									Caches.Metadatas.Tracks = setCache(Caches.Metadatas.Tracks, Settings.CacheSize);
									// ÂÜôÂÖ•ÊåÅ‰πÖÂåñÂÇ®Â≠ò
									Storage.setItem(`@DualSubs.${"Spotify"}.Caches.Metadatas.Tracks`, Caches.Metadatas.Tracks);
									break;
								case "rejected":
									log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `detectTrack.reason: ${JSON.stringify(results[1].reason)}`, "");
									break;
							}						});
					}			}			$request.url = url.toString();
			log(`üöß Ë∞ÉËØï‰ø°ÊÅØ`, `$request.url: ${$request.url}`, "");
			break;
		case false:
			break;
	}})()
	.catch((e) => logError(e))
	.finally(() => {
		switch ($response) {
			default: // ÊúâÊûÑÈÄ†ÂõûÂ§çÊï∞ÊçÆÔºåËøîÂõûÊûÑÈÄ†ÁöÑÂõûÂ§çÊï∞ÊçÆ
				//log(`üöß finally`, `echo $response: ${JSON.stringify($response, null, 2)}`, "");
				if ($response.headers?.["Content-Encoding"]) ;
				if ($response.headers?.["content-encoding"]) ;
				switch ($platform) {
					default:
						done({ response: $response });
						break;
					case "Quantumult X":
						if (!$response.status) $response.status = "HTTP/1.1 200 OK";
						delete $response.headers?.["Content-Length"];
						delete $response.headers?.["content-length"];
						delete $response.headers?.["Transfer-Encoding"];
						done($response);
						break;
				}				break;
			case undefined: // Êó†ÊûÑÈÄ†ÂõûÂ§çÊï∞ÊçÆÔºåÂèëÈÄÅ‰øÆÊîπÁöÑËØ∑Ê±ÇÊï∞ÊçÆ
				//log(`üöß finally`, `$request: ${JSON.stringify($request, null, 2)}`, "");
				done($request);
				break;
		}	});
