name: Extract plugin URLs & build sgmodule

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '5,30,55 * * * *'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    services:
      docker:
        image: xream/script-hub:latest
        ports: [9100:9100, 9101:9101]

    env:
      MIRROR_RAW: https://github.com/bunizao/Mirrored/raw/main/Chores/js
      MIRROR_KEY: github.com/bunizao/Mirrored

    steps:
      - uses: actions/checkout@v3

      - name: Setup git identity
        run: |
          git config --global user.name  "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install curl jq netcat
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y curl jq netcat-openbsd

      - name: Wait for Script-Hub container (:9101)
        run: |
          for i in {1..20}; do
            nc -z localhost 9101 && exit 0
            sleep 5
          done
          echo "::error ::container not ready"; exit 1

      # ---------- 1. Fetch the plugin list and extract source URLs ----------
      - name: Download plugin list
        run: |
          set -euo pipefail

          candidate_urls=(
            "https://hub.kelee.one/list.json"
          )

          browser_header="Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:122.0) Gecko/20100101 Firefox/122.0"

          for url in "${candidate_urls[@]}"; do
            echo "Trying: $url"
            if curl -fLsS -H "User-Agent: $browser_header" "$url" -o plugin_data.json && [ -s plugin_data.json ]; then
              echo "âœ“ Downloaded plugin catalog from $url"
              break
            fi
          done

          if [ ! -s plugin_data.json ]; then
            echo "::error ::Failed to download plugin list from all known endpoints"
            exit 1
          fi

      - name: Extract plugin source URLs
        run: |
          set -euo pipefail
          grep -oE 'https?://[^"]+\.(plugin|lpx)' plugin_data.json | sort -u > plugin_urls.txt

          plugin_count=$(wc -l < plugin_urls.txt)
          if [ "$plugin_count" -eq 0 ]; then
            echo "::error ::Plugin list JSON did not contain any .plugin/.lpx URLs"
            exit 1
          fi

          echo "Found $plugin_count plugin links:"
          cat plugin_urls.txt

      # ---------- 2. Ask Script-Hub to render .sgmodule files ----------
      - name: Generate sgmodule files
        run: |
          mkdir -p Chores/sgmodule
          find Chores/sgmodule -maxdepth 1 -type f -name "*.lpx.sgmodule" -delete
          category="ðŸš« AD Block"
          enc_cat=$(echo "$category" | jq -sRr @uri)
          while read -r plugin_url; do
            [ -z "$plugin_url" ] && continue
            url_no_query="${plugin_url%%[\?#]*}"
            base_name=$(basename "$url_no_query")

            name="$base_name"
            if [[ "$name" == *.lpx ]]; then
              name="${name%.lpx}"
            fi
            if [[ "$name" == *.plugin ]]; then
              name="${name%.plugin}"
            fi
            [ -z "$name" ] && name="$base_name"

            enc=$(echo "$name" | jq -sRr @uri)
            url="http://localhost:9101/file/_start_/${plugin_url}/_end_/${enc}.sgmodule?type=loon-plugin&target=surge-module&category=$enc_cat"
            echo "â†“  $url"
            curl -Ls -A "Surge Mac/2985" "$url" -o "Chores/sgmodule/$name.sgmodule" \
              || echo "::warning ::Failed to download $name.sgmodule"
          done < plugin_urls.txt

      # ---------- 3. Mirror external JS files and rewrite links ----------
      - name: Mirror external JS & rewrite links
        shell: bash
        run: |
          set -e
          mkdir -p Chores/js
          
          # Abort early if no sgmodule files were generated
          if [ ! -d "Chores/sgmodule" ] || [ -z "$(ls -A Chores/sgmodule 2>/dev/null)" ]; then
            echo "No sgmodule files found to process"
            exit 0
          fi
          
          echo "Generated sgmodule files:"
          ls -la Chores/sgmodule/
          
          # Extract every JavaScript URL referenced by the sgmodules
          echo "Searching for JS URLs..."
          
          # Use a precise regex to capture URLs that follow script-path
          find Chores/sgmodule -name "*.sgmodule" \
            -exec grep -hoE 'script-path\s*=\s*https?://[^[:space:],"]+\.js[^[:space:],"]*' {} \; 2>/dev/null \
            | sed -E 's/^script-path\s*=\s*//' \
            | sort -u > external-js-raw.txt || touch external-js-raw.txt
          
          echo "Found JavaScript URLs:"
          cat external-js-raw.txt || echo "No JS URLs found"
          
          # Filter out URLs that already point at the mirror
          if [ -s external-js-raw.txt ]; then
            grep -v "$MIRROR_KEY" external-js-raw.txt \
              | grep -v "$MIRROR_RAW" > external-js.txt \
              || touch external-js.txt
          else
            touch external-js.txt
          fi
          
          echo "External JS URLs to mirror:"
          cat external-js.txt || echo "No external JS URLs to mirror"

          # Nothing to mirror? Clean up and exit early
          if [ ! -s external-js.txt ]; then
            echo "No external JS links found to mirror."
            rm -f external-js.txt external-js-raw.txt
            exit 0
          fi

          # Download and mirror the JS files
          echo "Processing external JS files:"
          failed_downloads=0
          while IFS= read -r url; do
            [ -z "$url" ] && continue
            
            # Extract a filename while stripping any query string
            filename=$(basename "${url%%[\?#]*}")
            
            # Ensure the filename ends with .js
            if [[ ! "$filename" =~ \.js$ ]]; then
              filename="${filename}.js"
            fi
            
            echo "Mirroring: $url â†’ Chores/js/$filename"
            
            if curl -Ls -A "Surge Mac/3272" --connect-timeout 30 --max-time 60 "$url" -o "Chores/js/$filename"; then
              # Ensure the mirrored file has meaningful content
              if [ -s "Chores/js/$filename" ] && [ "$(stat -c%s "Chores/js/$filename")" -gt 10 ]; then
                echo "âœ“ Successfully downloaded $filename"
                
                # Rewrite every sgmodule reference with the mirrored URL
                mirror_url="$MIRROR_RAW/$filename"
                find Chores/sgmodule -name "*.sgmodule" -type f \
                  -exec perl -pi -e "s,\Q${url}\E,${mirror_url},g" {} \;
                
                echo "âœ“ Updated links: $url â†’ $mirror_url"
              else
                echo "âœ— Downloaded file is empty or too small: $filename"
                rm -f "Chores/js/$filename"
                ((failed_downloads++))
              fi
            else
              echo "âœ— Failed to download: $url"
              ((failed_downloads++))
            fi
          done < external-js.txt
          
          echo "Processing complete. Failed downloads: $failed_downloads"
          
          # Remove temporary files
          rm -f external-js.txt external-js-raw.txt

      - name: Commit & push (if changed)
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Skip committing when nothing was generated
          if [ ! -d "Chores/sgmodule" ] && [ ! -d "Chores/js" ]; then
            echo "No files to commit."
            exit 0
          fi

          # Stage managed artifacts
          git add Chores/sgmodule Chores/js 2>/dev/null || true

          # Bail out if staging area is empty
          if git diff --cached --quiet; then
            echo "Nothing to commit."
            exit 0
          fi

          # Show the staged changes
          echo "Changes to be committed:"
          git diff --cached --name-status

          # Sync with the latest upstream history
          git fetch origin
          if git diff --quiet HEAD origin/main; then
            echo "Local branch is up to date with origin/main"
          else
            echo "Pulling latest changes from origin..."
            git pull --rebase origin main
            
            # Re-stage files after a successful rebase
            git add Chores/sgmodule Chores/js 2>/dev/null || true
            
            # Abort if nothing remains staged after rebase
            if git diff --cached --quiet; then
              echo "Nothing to commit after rebase."
              exit 0
            fi
          fi

          # Commit and push the new artifacts
          commit_msg="Update sgmodule & mirror JS files - $(date '+%Y-%m-%d %H:%M:%S UTC')"
          git commit -m "$commit_msg"
          
          echo "Pushing changes..."
          git push origin main
          
          echo "âœ“ Successfully committed and pushed changes"
